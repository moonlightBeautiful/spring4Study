<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--default-autowire="byName"-->


    <!-- 5.级联注入，需要现在类中实例化属性，= new 类型() -->
    <!-- <bean id="hunter" class="com.java1234.entity.Hunter">
         <property name="id" value="4"></property>
         <property name="name" value="猎人4"></property>
         <property name="age" value="14"></property>
         <property name="dog.name" value="狗4"></property>
     </bean>-->




    <!-- bean类型参数自动（头部default-autowire属性）3种：根据名字、根据类型、根据构造方法 -->
    <!-- 不建议使用，很容易出错 -->
    <!-- 根据名字，不再演示，头部default-autowire属性=byName，bean的id和属性名相同，则自动匹配 -->
    <!-- 根据类型，不再演示，头部default-autowire属性=byName，bean的id和属性类型相同，则自动匹配 -->
    <!-- 根据名字，不再演示，头部default-autowire属性=byName，bean的id和属性名相同，则自动匹配 -->


    <!-- bean的作用域scope -->
    <!-- 1.单例，默认singleton，每次获取的bean都是同一个 -->
    <bean id="myDog1" class="com.java1234.entity.Dog" scope="singleton">
        <property name="name" value="jack"></property>
    </bean>
    <!-- 2.多例，prototype，每次获取的bean都是同新的-->
    <bean id="myDog2" class="com.java1234.entity.Dog" scope="prototype">
        <property name="name" value="jack"></property>
    </bean>
    <!-- 3.bean配置成单例，属性bean配置成多例，属性bean被外部bean修改为单例-->
    <bean id="hunter6" class="com.java1234.entity.Hunter" scope="singleton">
        <property name="id" value="3"></property>
        <property name="name" value="猎人3"></property>
        <property name="age" value="13"></property>
        <property name="dog" ref="myDog2"></property>
    </bean>
    <!-- bean配置成单例，属性bean配置成多例。属性bean可以更改成多例：1.把bean改成抽象 2.属性bean的getter方法改成抽象的 3.如下配置-->
    <!--<bean id="hunter7" class="com.java1234.entity.Hunter" scope="singleton">
        <property name="id" value="3"></property>
        <property name="name" value="猎人3"></property>
        <property name="age" value="13"></property>
        <lookup-method name="getDog"></lookup-method>
    </bean>-->



    <!-- beans的依赖关系3种：继承、引用、依赖 -->
    <!-- 1.继承：  如果大多数bean有相同的属性值，可以抽象出一个抽象bean，然后大多数继承这个抽象bean，大多数bean的就有相同的属性值了。 -->
    <bean id="abstractPeople" class="com.java1234.entity.Student" abstract="true">
        <property name="className" value="高三5班"></property>
        <property name="age" value="19"></property>
    </bean>
    <bean id="zhangsan" parent="abstractPeople">
        <property name="id" value="1"></property>
        <property name="name" value="张三"></property>
    </bean>
    <bean id="lisi" parent="abstractPeople">
        <property name="id" value="2"></property>
        <property name="name" value="李四"></property>
        <property name="age" value="20"></property>
    </bean>
    <!-- 2.引用：这里就不说了，一直在用 -->
    <!-- 3.依赖：依赖的bean先实例化后，才能实例化自己。-->
    <bean id="autority" class="com.java1234.com.java1234.service.Authority"></bean>
    <bean id="wangwu" parent="abstractPeople">
        <property name="id" value="2"></property>
        <property name="name" value="王五"></property>
        <property name="age" value="20"></property>
    </bean>

</beans>